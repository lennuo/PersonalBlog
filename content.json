{"meta":{"title":"小诺学习博客","subtitle":null,"description":"学习博客","author":"xiaonuolen","url":"https://lennuo.github.io/PersonalBlog"},"pages":[{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2021-02-16T11:56:15.422Z","comments":false,"path":"bangumi/index.html","permalink":"https://lennuo.github.io/PersonalBlog/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2021-02-17T07:37:15.228Z","comments":false,"path":"about/index.html","permalink":"https://lennuo.github.io/PersonalBlog/about/index.html","excerpt":"","text":"小诺鸭 与&nbsp; xiaonuo&nbsp; （ 小诺 ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2021-02-16T11:56:15.424Z","comments":false,"path":"client/index.html","permalink":"https://lennuo.github.io/PersonalBlog/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2021-02-16T11:56:15.425Z","comments":true,"path":"comment/index.html","permalink":"https://lennuo.github.io/PersonalBlog/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2021-02-16T11:56:15.427Z","comments":false,"path":"donate/index.html","permalink":"https://lennuo.github.io/PersonalBlog/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2021-02-16T11:56:15.428Z","comments":false,"path":"lab/index.html","permalink":"https://lennuo.github.io/PersonalBlog/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2021-02-16T11:56:15.430Z","comments":true,"path":"links/index.html","permalink":"https://lennuo.github.io/PersonalBlog/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2020-12-20T15:14:28.000Z","updated":"2021-02-17T06:37:02.024Z","comments":false,"path":"music/index.html","permalink":"https://lennuo.github.io/PersonalBlog/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2021-02-16T11:56:15.433Z","comments":true,"path":"rss/index.html","permalink":"https://lennuo.github.io/PersonalBlog/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2021-02-16T11:56:15.437Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://lennuo.github.io/PersonalBlog/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2021-02-16T11:56:15.435Z","comments":true,"path":"tags/index.html","permalink":"https://lennuo.github.io/PersonalBlog/tags/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2021-02-16T11:56:15.439Z","comments":false,"path":"video/index.html","permalink":"https://lennuo.github.io/PersonalBlog/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"【派大星的独白】一个关于正常人的故事","slug":"yule/paidaxin","date":"2021-02-17T13:47:59.000Z","updated":"2021-02-19T01:43:57.846Z","comments":false,"path":"2021/02/17/yule/paidaxin/","link":"","permalink":"https://lennuo.github.io/PersonalBlog/2021/02/17/yule/paidaxin/","excerpt":"","text":"来自bilibili视频引用 Up主：洛温阿特金森","categories":[{"name":"娱乐","slug":"娱乐","permalink":"https://lennuo.github.io/PersonalBlog/categories/娱乐/"}],"tags":[],"keywords":[{"name":"娱乐","slug":"娱乐","permalink":"https://lennuo.github.io/PersonalBlog/categories/娱乐/"}]},{"title":"【生僻字】（计算机版）计算机系人骄傲地把头抬起","slug":"yule/jisuanji","date":"2021-02-17T13:47:59.000Z","updated":"2021-02-19T01:43:57.662Z","comments":false,"path":"2021/02/17/yule/jisuanji/","link":"","permalink":"https://lennuo.github.io/PersonalBlog/2021/02/17/yule/jisuanji/","excerpt":"","text":"来自bilibili视频引用 Up主：派三叔iPython3","categories":[{"name":"娱乐","slug":"娱乐","permalink":"https://lennuo.github.io/PersonalBlog/categories/娱乐/"}],"tags":[],"keywords":[{"name":"娱乐","slug":"娱乐","permalink":"https://lennuo.github.io/PersonalBlog/categories/娱乐/"}]},{"title":"【MYSQL】事务篇","slug":"mianshi/mysql/suoying","date":"2021-02-15T00:11:22.000Z","updated":"2021-02-19T08:02:53.842Z","comments":false,"path":"2021/02/15/mianshi/mysql/suoying/","link":"","permalink":"https://lennuo.github.io/PersonalBlog/2021/02/15/mianshi/mysql/suoying/","excerpt":"","text":"事务四大特性(ACID)首先先来了解下什么叫作事务,一般来说一个事务对应着一个完整的业务,举个最常见的栗子(想念下沙举个栗子的第N天)一个银行转账就是能代表着一个事务：张三 转给李四1000 块钱,首先从张三的账户扣 1000 块钱,再加给李四的账户加 1000 块钱。 原子性一番操作后显示“转账成功”并扣了钱,打给李四询问情况,李四还没有收到张三的钱，而张三多扣了 1000 块钱,张三这少钱了不得来银行门口闹嘛! 这就说到了事务的第一个特性：原子性,保证共同成功或共同失败,不会出现一个成功,一个失败的情况。 一致性张三 来到了银行门口刚准备闹,经理把他拦了下来说：“这次我们已经把写这个BUG程序员祭天了,钱给您退回来了。”张三又开始了转账操作,给李四又转账了 1000 块钱,这次成功转过去了,张三打电话告知李四没想到被李四一顿臭骂:“你小子**是不是玩我,给我转个 250 是在骂我！！”。 这就是事务的第二个特性：一致性,确保状态一致的。转账服务中转出账户的扣除金额与转入账户的转入金额必须保持一致。 隔离性张三 又找到了银行经理, 气急败坏地刚准备开始讲优美的中国话, 只见天气突变, 一个没有什么头发的男子朝天飞去,经理说：“写出这个BUG的程序员也被祭天了,这次肯定也没有问题”。张三 又开始了一番操作, 可是银行人已经很多了开始排队了,排到了后又又一番操作。张三转完的同时, 旁边的王五正在给赵六转账 2000 元。操作结束后就打电话给了李四询问,没想到李四一直在道歉之前的行为,张三倍感奇怪,这时又飞出来一个秃头怪,张三瞬间明白怎么回事了,经理急忙过来说:“啊啊啊,不好意思,您的转给了 赵六 了,王五 的 2000 到了李四账户了,我们马上改马上改。” 这就是事务的第三个特性：隔离性,针对并发事务而言，事务必须在不干扰其他进程或事务的前提下独立执行。 持久性又又又一次操作后,张三终于把钱正常的转给了李四,查询了记录这次肯定没有错。 这就是事务的第四个特性：持久性,对数据所作的所有改动都必须在事务成功结束前保存至某种物理存储设备。这样可以保证，所作的修改在任何系统瘫痪时不至于丢失。 锁共享锁(S)读锁：事务A对数据对象加S锁的时候，A和其他的事务能加S锁，但都只能读，也不能加X锁 排他锁(X)读写锁：事务A加了对象X锁后，其他事务不能加任何锁，直到A释放 事务错误情况 脏读：事务A读到了事务B未提交的数据。 不可重复读：事务A第一次查询得到一行记录row1，事务B提交修改后，事务A第二次查询得到row1，但列内容发生了变化。 幻读：事务A第一次查询得到一行记录row1，事务B提交修改后，事务A第二次查询得到两行记录row1和row2。 隔离级别 结语愿世界和平、永无bug","categories":[{"name":"面试","slug":"面试","permalink":"https://lennuo.github.io/PersonalBlog/categories/面试/"}],"tags":[],"keywords":[{"name":"面试","slug":"面试","permalink":"https://lennuo.github.io/PersonalBlog/categories/面试/"}]},{"title":"【集合】HashTable-ConcurrentHashMap","slug":"mianshi/collection/HashTable-concurrentHashMap","date":"2020-07-11T14:11:22.000Z","updated":"2021-02-19T06:42:12.911Z","comments":false,"path":"2020/07/11/mianshi/collection/HashTable-concurrentHashMap/","link":"","permalink":"https://lennuo.github.io/PersonalBlog/2020/07/11/mianshi/collection/HashTable-concurrentHashMap/","excerpt":"","text":"HashTable线程安全性书接上回,说到了HashMap是不安全的,说到了HashTable是安全的,直接放源码 public synchronized V get(Object key) { Entry&lt;?,?&gt; tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) { if ((e.hash == hash) &amp;&amp; e.key.equals(key)) { return (V)e.value; } } return null; } public synchronized boolean containsKey(Object key) { Entry&lt;?,?&gt; tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) { if ((e.hash == hash) &amp;&amp; e.key.equals(key)) { return true; } } return false; } 看全部都是加了锁的,所以就是线程安全的了。 与HashMap的不同 HashMap的key可以为null,HashTable是不允许的因为HashTable有个安全失败机制这种机制会导致你读的数据都不一定是最新的,因此当key为null的时候,不确定他是真的包含还是真的没有 初始容量不同HashTable默认是11,HashMap是16 扩容不同HashMap是2倍,HashTable是2倍+1 迭代器不同HashMap迭代器是fail-fast(快速失败),HashTable不是,所以HashTable在迭代的时候可以修改增删数据 快速失败快速失败是java里面所有的集合都有的一个,当对一个集合进行迭代遍历的时候,如果进行增删改操作就会抛出异常,其中有一个变量modCount用来记录修改次数,还有一个变量expectedModCount则是表示迭代器对集合进行修改的次数。在进行next()/hasNext()的时候会检查两个值是否一样,不一样则会抛出异常。 缺点HashTable的优点是能够保证线程的安全性,同时这也是他的一个缺点,他一锁就会把整个对锁住,导致效率极低,因此出现了concurrentHashMap。 ConcurrentHashMapJDK1.7底层结构Segment+HashEntry(数组+链表) ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock, 所以要锁的时候就只会单独锁一个Segment,不会影响其他的Segment。 PUT首先尝试获得锁,如果失败就是有其他线程,那么就自旋尝试获得锁,到一定次数就改为阻塞锁获取先通过 key 定位到 HashEntry,遍历该 HashEntry, 如果不为空则遍历 key 和当前 key 比较是否相等, 相等就覆盖掉旧的 value为空的话就会新建一个 HashEntry 并加入到 Segment 中,同时判断是否需要扩容 GETget不需要修改数据,所以比较高效,第一次Hash到Segment,第二次Hash到具体的元素上。 缺点查询的时候，还得遍历链表，会导致效率很低，这个跟jdk1.7的HashMap是存在的一样问题，所以他在jdk1.8完全优化了。 JDK1.8底层结构Node+CAS+Synchronized PUT 根据 key 计算出 hashcode。 判断是否需要进行初始化。 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。 如果当前位置的 hashcode == MOVED == -1,则需要进行扩容。 如果都不满足，则利用 synchronized 锁写入数据。 如果数量大于 TREEIFY_THRESHOLD 则要转换为红黑树。 GET 先根据key的hash定位,如果在桶上直接返回 如果是红黑树那就按红黑树遍历 不满足就按链表方式遍历","categories":[{"name":"面试","slug":"面试","permalink":"https://lennuo.github.io/PersonalBlog/categories/面试/"}],"tags":[],"keywords":[{"name":"面试","slug":"面试","permalink":"https://lennuo.github.io/PersonalBlog/categories/面试/"}]},{"title":"【集合】HashMap","slug":"mianshi/collection/hashmap","date":"2020-07-10T12:11:22.000Z","updated":"2021-02-19T06:42:12.627Z","comments":false,"path":"2020/07/10/mianshi/collection/hashmap/","link":"","permalink":"https://lennuo.github.io/PersonalBlog/2020/07/10/mianshi/collection/hashmap/","excerpt":"","text":"HashMap存储结构JDK1.7底层数据结构是数组+链表 JDK.1.8底层数据结构是数组+链表+红黑树 PUT方法[1] 扩容机制默认大小为16,最大的容量是2^30,默认因子0.75 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; static final float DEFAULT_LOAD_FACTOR = 0.75f; 例如：16*0.75=12，默认创建一个map对象数组大小是16，当map添加12个元素到的时候就发生扩容， 创建新的数组的大小2*16=32，然后重新计算每个元素在新数组中的位置 HashMap的容量为什么是2的n次幂，和这个(n - 1) &amp; hash的计算方法有着千丝万缕的关系，符号&amp; 是按位与的计算，这是位运算，计算机能直接运算，特别高效，按位与&amp;的计算方法是，只有当对应位 置的数据都为1时，运算结果也为1，当HashMap的容量是2的n次幂时，(n-1)的2进制也就是1111111***111 这样形式的，这样与添加元素的hash值进行位运算时，能够充分的散列，使得添加的元素均匀分布在HashMap 的每个位置上，减少hash碰撞[2] 从代码可以看到扩容就是transfer()方法中用一个容量更大的数组来代替原有的数组 void resize(int newCapacity) { //传入新的容量 Entry[] oldTable = table; //引用扩容前的Entry数组 int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) { //扩容前的数组大小如果已经达到最大(2^30)了 threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了 return; } Entry[] newTable = new Entry[newCapacity]; //初始化一个新的Entry数组 transfer(newTable); //！！将数据转移到新的Entry数组里 table = newTable; //HashMap的table属性引用新的Entry数组 threshold = (int)(newCapacity * loadFactor);//修改阈值 } void transfer(Entry[] newTable) { Entry[] src = table; //src引用了旧的Entry数组 int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) { //遍历旧的Entry数组 Entry&lt;K,V&gt; e = src[j]; //取得旧Entry数组的每个元素 if (e != null) { src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象） do { Entry&lt;K,V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置 e.next = newTable[i]; //标记[1] newTable[i] = e; //将元素放在数组上 e = next; //访问下一个Entry链上的元素 } while (e != null); } } } JDK1.7使用的头插法(先进后出–栈),作者一开始的时候以为先进来的数据肯定会先用到,但是头插法有一个问题例(A-&gt;B-&gt;C) 那么插入顺序就是C-B-A 当多个线程同时扩容的时候,那么A先弹出去,接着是B,可能会是A同一个位置,因为头插法那么就会导致B-&gt;A,形成了死链 JDK1.8使用了尾插法(先进先出–队列)还是同样的例子(A-&gt;B-&gt;C),默认顺序是(A-B-C),就不会出现死链问题. 当然HashMap本身还是不完全的,他没有锁的保护.线程安全当然还要看HashTable和ConcurrentHashMap 引用资料[1] never疯 https://blog.csdn.net/qq_40574571/article/details/97612100[2] 猿人小郑 https://blog.csdn.net/Apeopl/article/details/88935422","categories":[{"name":"面试","slug":"面试","permalink":"https://lennuo.github.io/PersonalBlog/categories/面试/"}],"tags":[],"keywords":[{"name":"面试","slug":"面试","permalink":"https://lennuo.github.io/PersonalBlog/categories/面试/"}]}]}