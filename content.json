{"meta":{"title":"小诺学习博客","subtitle":null,"description":"学习博客","author":"xiaonuolen","url":"https://lennuo.github.io/PersonalBlog"},"pages":[{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2021-02-16T11:56:15.422Z","comments":false,"path":"bangumi/index.html","permalink":"https://lennuo.github.io/PersonalBlog/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2021-02-17T07:37:15.228Z","comments":false,"path":"about/index.html","permalink":"https://lennuo.github.io/PersonalBlog/about/index.html","excerpt":"","text":"小诺鸭 与&nbsp; xiaonuo&nbsp; （ 小诺 ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2021-02-16T11:56:15.424Z","comments":false,"path":"client/index.html","permalink":"https://lennuo.github.io/PersonalBlog/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2021-02-16T11:56:15.425Z","comments":true,"path":"comment/index.html","permalink":"https://lennuo.github.io/PersonalBlog/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2021-02-16T11:56:15.427Z","comments":false,"path":"donate/index.html","permalink":"https://lennuo.github.io/PersonalBlog/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2021-02-16T11:56:15.428Z","comments":false,"path":"lab/index.html","permalink":"https://lennuo.github.io/PersonalBlog/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2021-02-16T11:56:15.430Z","comments":true,"path":"links/index.html","permalink":"https://lennuo.github.io/PersonalBlog/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2020-12-20T15:14:28.000Z","updated":"2021-02-17T06:37:02.024Z","comments":false,"path":"music/index.html","permalink":"https://lennuo.github.io/PersonalBlog/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2021-02-16T11:56:15.433Z","comments":true,"path":"rss/index.html","permalink":"https://lennuo.github.io/PersonalBlog/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2021-02-16T11:56:15.435Z","comments":true,"path":"tags/index.html","permalink":"https://lennuo.github.io/PersonalBlog/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2021-02-16T11:56:15.437Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://lennuo.github.io/PersonalBlog/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2021-02-16T11:56:15.439Z","comments":false,"path":"video/index.html","permalink":"https://lennuo.github.io/PersonalBlog/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"【MAVEN】记一次因为Maven没有及时更新产生的问题","slug":"jishu/mavenproblem-2-21","date":"2021-02-21T03:11:22.000Z","updated":"2021-02-21T03:34:23.325Z","comments":false,"path":"2021/02/21/jishu/mavenproblem-2-21/","link":"","permalink":"https://lennuo.github.io/PersonalBlog/2021/02/21/jishu/mavenproblem-2-21/","excerpt":"","text":"2021-02-21 02:25:00今天把模块全部打包部署，一开始顺顺利利，测了一遍都没有问题，然后因为有一些显示的原因给路径多加了一个前缀，惨案来了，再次请求找不到了，feign请求404了，跑了下本地发现成功的，试了几次更换前缀都是成功的，打包去跑就是404，这个时候就感觉是打包时候缓存的问题，但不知道是哪块出了问题。第一反应是调用方，之前也出现过这个模块缓存不更新，尝试直接请求接口发现可以用的。然后去服务器上检查注册中心，发现也没有问题，那就肯定是打包出问题了。做了对照实验，一次用了第一次打包的路径，请求成功了。第二次随便输入，请求失败了。第三次修改了服务名称，feign用了修改后随便输入，发现他还是报的最早的路径。好了又被缓存坑了，接下来不管是clean也好，直接编译器清缓存都清空不掉，最气的是本地就是好好的，就给你打包后报。最后直接换了2019.3的编译器，以前一直用这个版本，新装了系统才装了2020.3的。不知道是重新加载的原因还是编译器的原因，反正修改了几个小问题就好了，然后发现公共包里面有一个引用问题，讲道理会报错的，之前居然平安无事地运行了半个月都没有提示。现在是2.25了，睡觉睡觉，本来今天还想早睡。 2021-02-21 11:28:00现在仔细想想也有可能是的那个没有修改的小bug的原因,因为报错可能导致依赖他生产者模块没有成功的重新加载,以后还是要多注意maven的坑,以前都没有这么在意过,这次写 微服务 项目的时候发生过好几次因为加载时候没有更新依赖出现的问题。","categories":[{"name":"开发","slug":"开发","permalink":"https://lennuo.github.io/PersonalBlog/categories/开发/"}],"tags":[],"keywords":[{"name":"开发","slug":"开发","permalink":"https://lennuo.github.io/PersonalBlog/categories/开发/"}]},{"title":"【MYSQL】索引基础篇","slug":"mianshi/mysql/suoying","date":"2021-02-19T11:04:22.000Z","updated":"2021-02-19T12:43:28.938Z","comments":false,"path":"2021/02/19/mianshi/mysql/suoying/","link":"","permalink":"https://lennuo.github.io/PersonalBlog/2021/02/19/mianshi/mysql/suoying/","excerpt":"","text":"张三接收了一个老项目,查数据的时候经常会被吐槽查询速度慢,数据出不来。终于它炸了,出不来数据了(又该祭天程序员了),经过检查发现数据多的已经查询数据库要几分钟了,这个时候 索引 站了出来 概念[1]我们知道数据库的数据最终它都会存储在文件中。那么我们查找id为1的数据时，我们会这么写：SELECT FROM person WHERE ID = 1.如果没有索引，我们怎么查询呢，我想我们只能读取文件，逐行扫描，找到符合的结果。如果 我们再来查询：SELECT FROM person WHERE ID = 3,那么有需要读取文件，逐行扫描，这样子效率会特别差。这时候就需要有一种东西可以帮助我们实现高效的获取数据。索引就这么出现了。在讨论索引之前，还要讨论一下底层文件系统是怎么样进行读取，写入数据的。 如图一，在文件系统中，table表是这么存储的，有一个文件名，文件名对应着一个三元组（柱面，磁道，扇区），当我们要去读机械硬盘时，我们需要通过我们的柱面，磁道定位到扇区，然后找到table.idb存储在图右磁盘的红色区域内，读取数据时（假设顺时钟），将会从A依次读到B,这就是原始存储和读取方式。所以当我们每次查找的时候都是需要如图2 中从A到B的扫描读取，效率很低。 索引数据结构索引默认用的数据结构是B+树,作为对比先聊聊Hash和B树。 Hash Hash我们知道是可以算出来Hash算法算出一个特定的下标,来存储数据。但是他适用于特定的查找,比如查找条件 age = 15,但如果查找条件 age &gt;= 14,那么他只能通过全表扫描,筛选出符合条件的数据。 数据量大的时候Hash的碰撞会比较严重。 无法进行索引排序 不支持多列联合索引的最左匹配规则 B树[1]首先先简单介绍下什么叫做B树(多路搜索树),一听名字为了搜索数据而生的,它不一定是二叉的哦。 定义非叶子节点的个数最多为M,且M&gt;2 根节点的儿子数为[2,M] 除根节点以外的非叶子节点的儿子数量[M/2,M] 每一个结点至少存放 M/2-1(向上取整)和最多M-1个关键字 非叶子节点的关键字个数 = 儿子个数 - 1 非叶子节点关键字:K[1],K[2]….K[M-1],且K[n] &lt; K[n+1] 非叶子节点的指针:P[1],P[2]….P[M],且P[1]指向的关键字小于K[1] 所有叶子节点位于同一层 B+树B+树是B树的一个扩展,提高IO性能,解决元素遍历效率低下 与B树的不同 有M棵子树的非叶子结点中含有M个关键字（b树是M-1个），这些关键字不保存数据，只用来索引，所有数据都保存在叶子节点（B树是每个关键字都保存数据）。 所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。 所有的非叶子结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。 优势 B+树的中间节点不保存数据，所以磁盘页能容纳更多节点元素，更“矮胖”； B+树查询必须查找到叶子节点，B树只要匹配到即可不用管元素位置，因此B+树查找更稳定（并不慢）； 对于范围查找来说，B+树只需遍历叶子节点链表即可，b树却需要重复地中序遍历 索引面试题[2]索引概念、索引模型我们是怎么聊到索引的呢，是因为我提到我们的业务量比较大，每天大概有几百万的新数据生成，于是有了以下对话：Q：你们每天这么大的数据量，都是保存在关系型数据库中吗？A：是的，我们线上使用的是MySQL数据库Q：每天几百万数据，一个月就是几千万了，那你们有没有对于查询做一些优化呢？A：我们在数据库中创建了一些索引（我现在非常后悔我当时说了这句话） 这里可以看到，阿里的面试官并不会像有一些公司一样拿着题库一道一道的问，而是会根据面试者做过的事情以及面试过程中的一些内容进行展开。 Q：那你能说说什么是索引吗？A：（这道题肯定难不住我啊）索引其实是一种数据结构，能够帮助我们快速的检索数据库中的数据Q：那么索引具体采用的哪种数据结构呢？A：（这道题我也背过）常见的MySQL主要有两种结构：Hash索引和B+ Tree索引，我们使用的是InnoDB引擎，默认的是B+树 这里我耍了一个小心机，特意说了一下索引和存储引擎有关。希望面试官可以问我一些关于存储引擎的问题。然而面试官并没有被我带跑… Q：既然你提到InnoDB使用的B+ 树的索引模型，那么你知道为什么采用B+ 树吗？这和Hash索引比较起来有什么优缺点吗？A：（突然觉得这道题有点难，但是我还是凭借着自己的知识储备简单的回答上一些）因为Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。而B+ 树是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描Q：除了上面这个范围查询的，你还能说出其他的一些区别吗？A：（这个题我回答的不好，事后百度了一下）B+ Tree索引和Hash索引区别？ 哈希索引适合等值查询，但是无法进行范围查询 哈希索引没办法利用索引完成排序 哈希索引不支持多列联合索引的最左匹配规则 如果有大量重复键值的情况下，哈希索引的效率会很低，因为存在哈希碰撞问题 聚簇索引、覆盖索引Q：刚刚我们聊到B+ Tree ，那你知道B+ Tree的叶子节点都可以存哪些东西吗？A：InnoDB的B+ Tree可能存储的是整行数据，也有可能是主键的值Q：那这两者有什么区别吗？A：（当他问我叶子节点的时候，其实我就猜到他可能要问我聚簇索引和非聚簇索引了）在 InnoDB 里，索引B+ Tree的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引。而索引B+ Tree的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引Q：那么，聚簇索引和非聚簇索引，在查询数据的时候有区别吗？A：聚簇索引查询会更快？Q：为什么呢？A：因为主键索引树的叶子节点直接就是我们要查询的整行数据了。而非主键索引的叶子节点是主键的值，查到主键的值以后，还需要再通过主键的值再进行一次查询Q：刚刚你提到主键索引查询只会查一次，而非主键索引需要回表查询多次。（后来我才知道，原来这个过程叫做回表）是所有情况都是这样的吗？非主键索引一定会查询多次吗？A：（额、这个问题我回答的不好，后来我自己查资料才知道，通过覆盖索引也可以只查询 覆盖索引？覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。当一条查询语句符合覆盖索引条件时，MySQL只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I/O提高效率。如，表covering_index_sample中有一个普通索引 idx_key1_key2(key1,key2)。当我们通过SQL语句：select key2 from covering_index_sample where key1 = ‘keytest’;的时候，就可以通过覆盖索引查询，无需回表。 联合索引、最左前缀匹配Q：不知道的话没关系，想问一下，你们在创建索引的时候都会考虑哪些因素呢？A：我们一般对于查询概率比较高，经常作为where条件的字段设置索引Q： 那你们有用过联合索引吗？A：用过呀，我们有对一些表中创建过联合索引Q：那你们在创建联合索引的时候，需要做联合索引多个字段之间顺序你们是如何选择的呢？A：我们把识别度最高的字段放到最前面Q：为什么这么做呢？A：（这个问题有点把我问蒙了，稍微有些慌乱）这样的话可能命中率会高一点吧。。。Q： 那你知道最左前缀匹配吗？A：（我突然想起来原来面试官是想问这个，怪自己刚刚为什么就没想到这个呢。）哦哦哦。您刚刚问的是这个意思啊，在创建多列索引时，我们根据业务需求，where子句中使用最频繁的一列放在最左边，因为MySQL索引查询会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。所以当我们创建一个联合索引的时候，如(key1,key2,key3)，相当于创建了（key1）、(key1,key2)和(key1,key2,key3)三个索引，这就是最左匹配原则 索引下推、查询优化Q：你们线上用的MySQL是哪个版本啊呢？A：我们MySQL是5.7Q：那你知道在MySQL 5.6中，对索引做了哪些优化吗？A：不好意思，这个我没有去了解过。（事后我查了一下，有一个比较重要的 ：Index Condition Pushdown Optimization） 查询优化器？一条SQL语句的查询，可以有不同的执行方案，至于最终选择哪种方案，需要通过优化器进行选择，选择执行成本最低的方案。在一条单表查询语句真正执行之前，MySQL的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案。这个成本最低的方案就是所谓的执行计划。优化过程大致如下：1、根据搜索条件，找出所有可能使用的索引2、计算全表扫描的代价3、计算使用不同索引执行查询的代价4、对比各种执行方案的代价，找出成本最低的那一个 感觉是因为我回答的不够好，如果这几个索引问题我都会的话，他还会追问更多，恐怕会被虐的更惨 总结&amp;感悟以上，就是一次面试中关于索引部分知识的问题以及我整理的答案。感觉这次面试过程中关于索引的知识，自己大概能够回答的内容占70%左右，但是自信完全答对的内容只占50%左右，看来自己索引有关的知识了解的还是不够多。 通过这次面试，发现像阿里这种大厂对于底层知识还是比较看重的，我以前以为关于索引最多也就问一下Hash和B+有什么区别，没想到最后都能问到查询优化器上面。 最后，不管本次面试能不能通过，都非常感谢有这样一次机会，可以让自己看到自己的不足。通过这次面试，我也收获了很多东西。加油！ 引用资料[1] Object_PigMan https://blog.csdn.net/javawcj123/article/details/79824020[2] Hollis https://mp.weixin.qq.com/s/_bk2JVOm2SkXfdcvki6-0w","categories":[{"name":"面试","slug":"面试","permalink":"https://lennuo.github.io/PersonalBlog/categories/面试/"}],"tags":[],"keywords":[{"name":"面试","slug":"面试","permalink":"https://lennuo.github.io/PersonalBlog/categories/面试/"}]},{"title":"【MYSQL】事务篇","slug":"mianshi/mysql/shiwu","date":"2021-02-19T00:11:22.000Z","updated":"2021-02-19T13:22:27.533Z","comments":false,"path":"2021/02/19/mianshi/mysql/shiwu/","link":"","permalink":"https://lennuo.github.io/PersonalBlog/2021/02/19/mianshi/mysql/shiwu/","excerpt":"","text":"事务四大特性(ACID)首先先来了解下什么叫作事务,一般来说一个事务对应着一个完整的业务,举个最常见的栗子(想念下沙举个栗子的第N天)一个银行转账就是能代表着一个事务：张三 转给李四1000 块钱,首先从张三的账户扣 1000 块钱,再加给李四的账户加 1000 块钱。 原子性一番操作后显示“转账成功”并扣了钱,打给李四询问情况,李四还没有收到张三的钱，而张三多扣了 1000 块钱,张三这少钱了不得来银行门口闹嘛! 这就说到了事务的第一个特性：原子性,保证共同成功或共同失败,不会出现一个成功,一个失败的情况。 一致性张三 来到了银行门口刚准备闹,经理把他拦了下来说：“这次我们已经把写这个BUG程序员祭天了,钱给您退回来了。”张三又开始了转账操作,给李四又转账了 1000 块钱,这次成功转过去了,张三打电话告知李四没想到被李四一顿臭骂:“你小子**是不是玩我,给我转个 250 是在骂我！！”。 这就是事务的第二个特性：一致性,确保状态一致的。转账服务中转出账户的扣除金额与转入账户的转入金额必须保持一致。 隔离性张三 又找到了银行经理, 气急败坏地刚准备开始讲优美的中国话, 只见天气突变, 一个没有什么头发的男子朝天飞去,经理说：“写出这个BUG的程序员也被祭天了,这次肯定也没有问题”。张三在操作的同时王五给他转了500块钱,读到的是扣了1000块钱的账户余额,但是转给李四的时候账号写错了,导致没有转过去,把账户余额原样,但王五转账操作还是从扣1000块钱的基础上加了500,张三发现自己转账钱没有收到,还平白无故少了500块钱,,经理急忙过来说:“啊啊啊,不好意思,我们又出问题了,这就拿程序员祭天。” 这就是事务的第三个特性：隔离性,针对并发事务而言，事务必须在不干扰其他进程或事务的前提下独立执行，这个例子中出现了脏读王五转进来成功了,但是 持久性又又又一次操作后,张三终于把钱正常的转给了李四,查询了记录这次肯定没有错。 这就是事务的第四个特性：持久性,对数据所作的所有改动都必须在事务成功结束前保存至某种物理存储设备。这样可以保证，所作的修改在任何系统瘫痪时不至于丢失。 锁共享锁(S)读锁：事务A对数据对象加S锁的时候，A和其他的事务能加S锁，但都只能读，也不能加X锁 排他锁(X)读写锁：事务A加了对象X锁后，其他事务不能加任何锁，直到A释放 事务错误情况 脏读：事务A读到了事务B未提交的数据。例如：事务B执行过程中修改了数据X，在未提交前，事务A读取了X，而事务B却回滚了，这样事务A就形成了脏读。 不可重复读：事务A第一次查询得到一行记录row1，事务B提交修改后，事务A第二次查询得到row1，但列内容发生了变化(数据修改)。 幻读：事务A首先根据条件索引得到N条数据，然后事务B改变了这N条数据之外的M条或者增添了M条符合事务A搜索条件的数据，导致事务A再次搜索发现有N+M条数据了，就产生了幻读(数据增加)。 隔离级别 结语愿世界和平、永无bug","categories":[{"name":"面试","slug":"面试","permalink":"https://lennuo.github.io/PersonalBlog/categories/面试/"}],"tags":[],"keywords":[{"name":"面试","slug":"面试","permalink":"https://lennuo.github.io/PersonalBlog/categories/面试/"}]},{"title":"【生僻字】（计算机版）计算机系人骄傲地把头抬起","slug":"yule/jisuanji","date":"2021-02-17T13:47:59.000Z","updated":"2021-02-19T01:43:57.662Z","comments":false,"path":"2021/02/17/yule/jisuanji/","link":"","permalink":"https://lennuo.github.io/PersonalBlog/2021/02/17/yule/jisuanji/","excerpt":"","text":"来自bilibili视频引用 Up主：派三叔iPython3","categories":[{"name":"娱乐","slug":"娱乐","permalink":"https://lennuo.github.io/PersonalBlog/categories/娱乐/"}],"tags":[],"keywords":[{"name":"娱乐","slug":"娱乐","permalink":"https://lennuo.github.io/PersonalBlog/categories/娱乐/"}]},{"title":"【派大星的独白】一个关于正常人的故事","slug":"yule/paidaxin","date":"2021-02-17T13:47:59.000Z","updated":"2021-02-19T01:43:57.846Z","comments":false,"path":"2021/02/17/yule/paidaxin/","link":"","permalink":"https://lennuo.github.io/PersonalBlog/2021/02/17/yule/paidaxin/","excerpt":"","text":"来自bilibili视频引用 Up主：洛温阿特金森","categories":[{"name":"娱乐","slug":"娱乐","permalink":"https://lennuo.github.io/PersonalBlog/categories/娱乐/"}],"tags":[],"keywords":[{"name":"娱乐","slug":"娱乐","permalink":"https://lennuo.github.io/PersonalBlog/categories/娱乐/"}]},{"title":"【集合】HashMap","slug":"mianshi/collection/hashmap","date":"2021-02-16T12:11:22.000Z","updated":"2021-02-19T11:12:24.514Z","comments":false,"path":"2021/02/16/mianshi/collection/hashmap/","link":"","permalink":"https://lennuo.github.io/PersonalBlog/2021/02/16/mianshi/collection/hashmap/","excerpt":"","text":"HashMap存储结构JDK1.7底层数据结构是数组+链表 JDK.1.8底层数据结构是数组+链表+红黑树 PUT方法[1] 扩容机制默认大小为16,最大的容量是2^30,默认因子0.75 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; static final float DEFAULT_LOAD_FACTOR = 0.75f; 例如：16*0.75=12，默认创建一个map对象数组大小是16，当map添加12个元素到的时候就发生扩容， 创建新的数组的大小2*16=32，然后重新计算每个元素在新数组中的位置 HashMap的容量为什么是2的n次幂，和这个(n - 1) &amp; hash的计算方法有着千丝万缕的关系，符号&amp; 是按位与的计算，这是位运算，计算机能直接运算，特别高效，按位与&amp;的计算方法是，只有当对应位 置的数据都为1时，运算结果也为1，当HashMap的容量是2的n次幂时，(n-1)的2进制也就是1111111***111 这样形式的，这样与添加元素的hash值进行位运算时，能够充分的散列，使得添加的元素均匀分布在HashMap 的每个位置上，减少hash碰撞[2] 从代码可以看到扩容就是transfer()方法中用一个容量更大的数组来代替原有的数组 void resize(int newCapacity) { //传入新的容量 Entry[] oldTable = table; //引用扩容前的Entry数组 int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) { //扩容前的数组大小如果已经达到最大(2^30)了 threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了 return; } Entry[] newTable = new Entry[newCapacity]; //初始化一个新的Entry数组 transfer(newTable); //！！将数据转移到新的Entry数组里 table = newTable; //HashMap的table属性引用新的Entry数组 threshold = (int)(newCapacity * loadFactor);//修改阈值 } void transfer(Entry[] newTable) { Entry[] src = table; //src引用了旧的Entry数组 int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) { //遍历旧的Entry数组 Entry&lt;K,V&gt; e = src[j]; //取得旧Entry数组的每个元素 if (e != null) { src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象） do { Entry&lt;K,V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置 e.next = newTable[i]; //标记[1] newTable[i] = e; //将元素放在数组上 e = next; //访问下一个Entry链上的元素 } while (e != null); } } } JDK1.7使用的头插法(先进后出–栈),作者一开始的时候以为先进来的数据肯定会先用到,但是头插法有一个问题例(A-&gt;B-&gt;C) 那么插入顺序就是C-B-A 当多个线程同时扩容的时候,那么A先弹出去,接着是B,可能会是A同一个位置,因为头插法那么就会导致B-&gt;A,形成了死链 JDK1.8使用了尾插法(先进先出–队列)还是同样的例子(A-&gt;B-&gt;C),默认顺序是(A-B-C),就不会出现死链问题. 当然HashMap本身还是不完全的,他没有锁的保护.线程安全当然还要看HashTable和ConcurrentHashMap 引用资料[1] never疯 https://blog.csdn.net/qq_40574571/article/details/97612100[2] 猿人小郑 https://blog.csdn.net/Apeopl/article/details/88935422","categories":[{"name":"面试","slug":"面试","permalink":"https://lennuo.github.io/PersonalBlog/categories/面试/"}],"tags":[],"keywords":[{"name":"面试","slug":"面试","permalink":"https://lennuo.github.io/PersonalBlog/categories/面试/"}]},{"title":"【集合】HashTable-ConcurrentHashMap","slug":"mianshi/collection/HashTable-concurrentHashMap","date":"2021-02-16T11:02:12.000Z","updated":"2021-02-19T11:05:30.162Z","comments":false,"path":"2021/02/16/mianshi/collection/HashTable-concurrentHashMap/","link":"","permalink":"https://lennuo.github.io/PersonalBlog/2021/02/16/mianshi/collection/HashTable-concurrentHashMap/","excerpt":"","text":"HashTable线程安全性书接上回,说到了HashMap是不安全的,说到了HashTable是安全的,直接放源码 public synchronized V get(Object key) { Entry&lt;?,?&gt; tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) { if ((e.hash == hash) &amp;&amp; e.key.equals(key)) { return (V)e.value; } } return null; } public synchronized boolean containsKey(Object key) { Entry&lt;?,?&gt; tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) { if ((e.hash == hash) &amp;&amp; e.key.equals(key)) { return true; } } return false; } 看全部都是加了锁的,所以就是线程安全的了。 与HashMap的不同 HashMap的key可以为null,HashTable是不允许的因为HashTable有个安全失败机制这种机制会导致你读的数据都不一定是最新的,因此当key为null的时候,不确定他是真的包含还是真的没有 初始容量不同HashTable默认是11,HashMap是16 扩容不同HashMap是2倍,HashTable是2倍+1 迭代器不同HashMap迭代器是fail-fast(快速失败),HashTable不是,所以HashTable在迭代的时候可以修改增删数据 快速失败快速失败是java里面所有的集合都有的一个,当对一个集合进行迭代遍历的时候,如果进行增删改操作就会抛出异常,其中有一个变量modCount用来记录修改次数,还有一个变量expectedModCount则是表示迭代器对集合进行修改的次数。在进行next()/hasNext()的时候会检查两个值是否一样,不一样则会抛出异常。 缺点HashTable的优点是能够保证线程的安全性,同时这也是他的一个缺点,他一锁就会把整个对锁住,导致效率极低,因此出现了concurrentHashMap。 ConcurrentHashMapJDK1.7底层结构Segment+HashEntry(数组+链表) ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock, 所以要锁的时候就只会单独锁一个Segment,不会影响其他的Segment。 PUT首先尝试获得锁,如果失败就是有其他线程,那么就自旋尝试获得锁,到一定次数就改为阻塞锁获取先通过 key 定位到 HashEntry,遍历该 HashEntry, 如果不为空则遍历 key 和当前 key 比较是否相等, 相等就覆盖掉旧的 value为空的话就会新建一个 HashEntry 并加入到 Segment 中,同时判断是否需要扩容 GETget不需要修改数据,所以比较高效,第一次Hash到Segment,第二次Hash到具体的元素上。 缺点查询的时候，还得遍历链表，会导致效率很低，这个跟jdk1.7的HashMap是存在的一样问题，所以他在jdk1.8完全优化了。 JDK1.8底层结构Node+CAS+Synchronized PUT 根据 key 计算出 hashcode。 判断是否需要进行初始化。 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。 如果当前位置的 hashcode == MOVED == -1,则需要进行扩容。 如果都不满足，则利用 synchronized 锁写入数据。 如果数量大于 TREEIFY_THRESHOLD 则要转换为红黑树。 GET 先根据key的hash定位,如果在桶上直接返回 如果是红黑树那就按红黑树遍历 不满足就按链表方式遍历","categories":[{"name":"面试","slug":"面试","permalink":"https://lennuo.github.io/PersonalBlog/categories/面试/"}],"tags":[],"keywords":[{"name":"面试","slug":"面试","permalink":"https://lennuo.github.io/PersonalBlog/categories/面试/"}]}]}