{"meta":{"title":"小诺学习博客","subtitle":null,"description":"学习博客","author":"xiaonuolen","url":"https://lennuo.github.io/PersonalBlog"},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2021-02-17T07:37:15.228Z","comments":false,"path":"about/index.html","permalink":"https://lennuo.github.io/PersonalBlog/about/index.html","excerpt":"","text":"小诺鸭 与&nbsp; xiaonuo&nbsp; （ 小诺 ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2021-02-16T11:56:15.422Z","comments":false,"path":"bangumi/index.html","permalink":"https://lennuo.github.io/PersonalBlog/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2021-02-16T11:56:15.424Z","comments":false,"path":"client/index.html","permalink":"https://lennuo.github.io/PersonalBlog/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2021-02-16T11:56:15.425Z","comments":true,"path":"comment/index.html","permalink":"https://lennuo.github.io/PersonalBlog/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2021-02-16T11:56:15.427Z","comments":false,"path":"donate/index.html","permalink":"https://lennuo.github.io/PersonalBlog/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2021-02-16T11:56:15.428Z","comments":false,"path":"lab/index.html","permalink":"https://lennuo.github.io/PersonalBlog/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2021-02-16T11:56:15.430Z","comments":true,"path":"links/index.html","permalink":"https://lennuo.github.io/PersonalBlog/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2020-12-20T15:14:28.000Z","updated":"2021-02-17T06:37:02.024Z","comments":false,"path":"music/index.html","permalink":"https://lennuo.github.io/PersonalBlog/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2021-02-16T11:56:15.433Z","comments":true,"path":"rss/index.html","permalink":"https://lennuo.github.io/PersonalBlog/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2021-02-16T11:56:15.435Z","comments":true,"path":"tags/index.html","permalink":"https://lennuo.github.io/PersonalBlog/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2021-02-16T11:56:15.437Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://lennuo.github.io/PersonalBlog/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2021-02-16T11:56:15.439Z","comments":false,"path":"video/index.html","permalink":"https://lennuo.github.io/PersonalBlog/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"【操作系统】进程管理","slug":"mianshi/system","date":"2021-03-02T06:40:22.000Z","updated":"2021-03-02T09:58:58.115Z","comments":false,"path":"2021/03/02/mianshi/system/","link":"","permalink":"https://lennuo.github.io/PersonalBlog/2021/03/02/mianshi/system/","excerpt":"","text":"进程状态五个状态 新建状态 就绪状态 运行状态 等待状态 结束状态 状态变化就绪-运行当处于就绪状态的进程被选中的时候就变成了运行状态。 运行-阻塞碰见某些要等待的事件时,线程就从运行变成阻塞。 运行-就绪当时间片用完但是工作还没有做完的时候,从运行变成就绪。 阻塞-就绪处于阻塞状态的进程若等待的事件发生了就变成了就绪状态。 创建-就绪进程初始化完成后一切就绪就从创建变成就绪状态。 当前操作系统把进程队列管理起来,节省查找时间,同一个优先级到同一个队列中,系统首先先找最高优先级队列队首进入处理机,当时间片结束的时候重新放回就绪队列。如果碰见了等待事件时候则放入等待队列,如果相应的事件发生则加入到就绪队列,并重新计算优先级。 进程的挂起在系统出现故障或负载过高的情况下进程可以变成挂起状态,交换位置到辅存中,挂起的状态可以是自己发出但解除挂起要有其他进程发出。 主要的状态转换 等待-挂起等待如果没有就绪进程那么至少要空出一个位置以后要来的就绪进程,所以将一个等待线程挂起 挂起等待-挂起就绪如果等待的事件发生了,那么就变成了挂起就绪状态 挂起就绪-就绪当没有就绪进程的时候,操作系统需要一个进程运行,如果操作系统规定优先级高并且挂起就绪的线程优先级比所有就绪优先级的都要高的时候,那么就进行状态转换 就绪-挂起就绪一般操作系统优先考虑等待的进程但如果没有的话也只能挂起一个就绪状态的进程 新建-挂起就绪 或 新建-就绪操作系统一开始新建的时候就会有大量的未阻塞的进程,会消耗很大的开销 挂起阻塞-阻塞这种情况比较少,但如果一个挂起阻塞的比所有就绪的优先级都要高并且系统认定等待事件马上要发生,那么这个就是合理的 运行-挂起就绪当时间片满了的,挂起阻塞的优先级比较高并且变得不再阻塞了,那么就让出位置变成挂起就绪状态 各种状态-退出某些操作系统进程可以被创建进程或父进程关闭,那么他从什么状态都可以退出 进程的描述与管理进程的描述在操作系统中通常有一个进程控制块（PCB）的数据结构来记录进程信息 进程标识信息 本进程的标识符ID,一般系统中唯一的数字 本进程的进程(父进程)的标识ID 用户标识 处理器状态信息 用户使用的寄存器 控制和状态寄存器(程序计数器和条件寄存器) 堆栈指针 进程控制信息 进程和状态信息(进程的状态、调度优先级、相关信息) 有关队列的链指针 进程间的通信信息(标志位、信号或信号量、消息队列) 主存使用信息,分给进程的主存大小和位置 进程使用的其他资源信息 进程相关服务的优先级 进程管理大致的几个方法： 把所有不同状态的进程的PCB组到一张表中,但是每一次查询都要扫描整个表 把分别有着相同状态的进程的PCB组到一张表格中,分别就有了就绪进程、运行进程、等待事件的等待进程 分别把具有相同状态的所有进程的PCB按优先级排成一个或多个队列 进程控制控制原语系统提供了若干的操作,这种称为:原语,是指一系列指令组成的集合,他们具有原子性常见的控制原语:建立一个进程原语、撤销一个进程原语、挂起一个进程原语、解除挂起原语、改变优先数原语、阻塞一个进程原语、唤醒一个进程原语、调度进程原语 建立一个进程原语倘若一个进程需要那么就由它建立一个新的进程,被建立的进程称为子进程,而它被称为父进程,所有进程都只能由父进程建立不会自生自灭,这就是进程树的来源Unix中操作系统初始化创建的1号进程是所有用户进程的祖先,会为每一个终端登录系统的用户创建一个终端进程,这些终端进程又会创建他们的子进程具体原语中的命令：(1) 设置初始值、优先级、初始执行程序描述(2) 建立一个PCB(进程控制块),填入相应初始值(3) 产生描述进程空间的数据结构(页表、程序区、栈区、堆区等)(4) 进程运行初始值初始化 处理机现场保护区。构造一个现场栈帧,等该进程第一次被调度后会从该栈帧恢复现场,从而能够进入用户程序的入口点运行(5) 置好父进程等关系域(6) 进程设置成就绪状态(7) 将PCB表挂入就绪队列,等待被调用运行 挂起进程原语挂起只能该族系的进程,不能是其他的不然就会定义为非法挂起方法:(1) 发命令的进程挂起(2) 具有指定标识符的进程挂起(3) 某进程及全部或部分的子孙挂起挂起过程:(1) 检查被挂起进程的状态并进行相应操作(2) 方便于用户或父进程考查该进程的运行情况,把该进程的PCB复制到指定的内存区域,为了在需要时候进一步的挂起该进程的子孙(3) 若挂起的进程正在执行,则转向调度程序重新调度,将处理机重新分配 解除挂起原语进程把自己的子孙进程解挂,假如解挂后是活动就绪,由于长时间挂起优先级可能会变 撤销进程原语当一个进程完成任务时应该撤销掉,但都由祖先进程发出,不能自己撤销自己。撤销也有两个策略：(1) 撤销进程一个,但这个会导致进程树断裂,一般都是第二种(2) 撤销进程的所有子孙 改变进程优先数原语防止一些进程长时间不被允许而导致是不是被丢弃进程优先数与以下相关：(1) 与作业开始时的静态优先数相关,取决于作业的重要程度、付出的价格和费用大小、作业类型(2) 与进程的类型相关,系统&gt;用户、IO&gt;CPU(3) 与进程使用的资源相关,CPU使用的越多,优先级越低(4) 与等待时间相关,等待时间越长优先数越高 改变进程的优先数原语大致：(1) 根据进程外部名找到内部名,根据优先数计算公式计算出优先数然后登记到PCB下(2) 当进程的状态为活动就绪时候,加入就绪队列,并将对比运行的进程决定是否可以抢用 进程结束通常进程结束有正常终止、异常结束、外界干预三个情况进程结束时候操作系统的处理：(1) 先在PCB进程链或进程家族,查找是否存在,如果找到了就用撤销原语释放该进程占用的所有资源,把对应的PCB结构从家族或链中删除并返回给PCB空队列,如果有子进程那么就先撤销子进程(2) 关闭所有打开使用的文件、设备(3) 脱离用户进程与其所执行程序文件的映射关系(4) 进行相关统计,记录日志模块(5) 清理相关进程的链接关系(6) 释放进程空间和进程控制块空间(7) 调用进程调度程序,将处理机转到其他进程运行 中断方式 时钟中断运行的时间片刀时钟中断处理程序或定时时钟唤醒实时进程或延迟处理,这时中断处理程序将调用进程调度程序调度其他进程来执行 IO设备中断I/O正常完成,发现有多个进程在等待IO完成,那么这些进程状态改为就绪 存储访问故障中断如果访问的地址不存在主存中那么就需要把他们调到主存中需要长时间,因此调度其他就绪进程 访问管理程序中断当处理器发现用户程序中的指令是访管指令则自动触发本中断,访管指令的中断管理程序调用相应管理程序为用户进程服务:如启动I/O,打开文件,分配主机等通常对导致阻塞。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://lennuo.github.io/PersonalBlog/categories/笔记/"}],"tags":[],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://lennuo.github.io/PersonalBlog/categories/笔记/"}]},{"title":"【ROCKETMQ】RocketMQ-NameServer(未完成)","slug":"jishu/rocketmq--nameServer启动","date":"2021-02-27T03:11:22.000Z","updated":"2021-03-02T08:51:10.432Z","comments":false,"path":"2021/02/27/jishu/rocketmq--nameServer启动/","link":"","permalink":"https://lennuo.github.io/PersonalBlog/2021/02/27/jishu/rocketmq--nameServer启动/","excerpt":"","text":"NameServer启动流程配置config属性先进入createNamesrvController()方法解析配置文件,填充NamesrvConfig的属性（(NameServer业务参数)）和NettyServerConfig的属性值(NameServer网络参数) 配置NamesrvConfig属性 rocketmqHome：rocketMQ主目录,可以通过-Drocketmq.home.dir=path或者通过设置环境变量ROCKETMQ_HOME来配置RocketMQ的主目录 kvConfigPath:NameServer存储KV配置属性的持久化路径 configStorePath:nameServer 默认配置文件路径,不生效。nameServer启动时如果要通过配置文件配置NameServer启动属性的话,使用c选项 orderMessageEnable：是否支持顺序消息,默认不支持。 NettyServerConfig配置listenPort = 8888; NameServer监听端口,默认初始化是9876 serverWorkerThreads = 8; Netty业务线程池线程的个数 serverCallbackExecutorThreads = 0; Netty public任务线程池线程个数,Netty网络设计,根据业务类型的不同创建不同的线程池,比如消息发送、消息消费、心跳检测,如果业务该类型未注册线程池,则由public线程池执行。 serverSelectorThreads = 3; IO线程池的个数,主要是NameServer、Broker端解析请求、返回相应的线程个数。这类线程主要是处理网络请求的解析请求包,如何转到各个业务线程池完成具体的业务操作,再将结果返回调用方 serverOnewaySemaphoreValue = 256; send oneway消息请求并发度（Broker端参数） serverAsyncSemaphoreValue = 64; 异步消息发送最大并发度（Broker端参数） serverChannelMaxIdleTimeSeconds = 120; 网络连接最大空闲时间、默认120s,如果连接超过参数设置的值则被关闭 serverSocketSndBufSize = NettySystemConfig.socketSndbufSize; 网络socket发送缓存区大小,默认64k serverSocketRcvBufSize = NettySystemConfig.socketRcvbufSize; 网络socket接受缓存区大小,默认64k serverPooledByteBufAllocatorEnable = true; ByteBuffer是否开启缓存,建议开启 useEpollNativeSelector 是否启动用Epoll IO模型,Linux环境建议开启。 创建NamesrvController实例根据启动属性创建NamesrvController实例,并初始化该实例,NameServerController为NameServer核心控制器 创建NettyServer网络处理对象,开启两个定时任务（心跳检测）定时任务1：NameServer每隔10s扫描一次Broker,移除不激活状态的Broker定时任务2：NameServer每隔10分钟打印一次KV配置 注册JVM钩子函数注册JVM钩子函数并启动服务器,以便监听Broker、消息生产者的网络请求。 如果代码中使用到了线程池,可以先注册JVM钩子函数,在JVM关闭之前将线程池关闭掉,释放资源。（钩子函数：在JVM关闭的之前调用该函数） NameServer路由实现类NameServer存储信息: topicQueueTable：Topic消息队列路由信息,消息发送时根据路由表进行负载均衡。brokerAddrTable：Broker基础信息,包含brokerName、所属集群名称、主备Broker地址clusterAddrTable：Broker集群信息,存储集群中所有的Broker名称brokerLiveTable： Broker状态信息,NameServer每次收到心跳包会替换该信息filterServerTable：Broker上的FilterServer列表,用于类模式消息过滤 RocketMQ基于订阅房补机制,一个Topic拥有多个消息队列,一个Broker为每一主题默认创建4个读队列4个写队列。多个Broker组成集群,BrokerName由相同的Broker组成的Master-Slave架构,brokerId为0代表Master,大于0代表Salve。BrokerLiveInfo中lastUpdateTimestamp村粗上一次收到broker心跳包的时间 路由注册RocketMQ的路由注册通过Broker与NameServer的心跳功能来实现的,Broker在启动的时候向所有的NameServer发送心跳语句,每隔30s向集群中所有的NameServer发送心跳包,NameServer收到Broker心跳包会更新brokerLiveTable缓存中BrokerLiveInfo的lastUpdateTimestamp,如何NameServer会每隔10s扫描brokerLiveTable,如果连续120s没有收到心跳包,则移除Broker路由信息,同时关闭socket连接","categories":[{"name":"笔记","slug":"笔记","permalink":"https://lennuo.github.io/PersonalBlog/categories/笔记/"}],"tags":[],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://lennuo.github.io/PersonalBlog/categories/笔记/"}]},{"title":"【ROCKETMQ】RocketMQ-前篇","slug":"jishu/rocketmq--前言","date":"2021-02-27T03:11:22.000Z","updated":"2021-03-02T08:50:13.408Z","comments":false,"path":"2021/02/27/jishu/rocketmq--前言/","link":"","permalink":"https://lennuo.github.io/PersonalBlog/2021/02/27/jishu/rocketmq--前言/","excerpt":"","text":"前言第一次在使用RocketMQ还是在实习公司的时候,那个时候对他就很感兴趣,这段时间刚刚好买了一本丁威老师和周继锋老师的&lt;&lt;RoccketMQ技术内幕&gt;&gt;,对我们这种新人书很棒,也是一本值得反复去读的书,相信我在工作几年后再去回顾会有不一样的感受 基本架构 NameServer可以理解为是消息队列的协调者,Broker向它注册路由信息,同时Client向其获取路由信息,如果使用过Zookeeper,就比较容易理解了,但是功能比Zookeeper弱;NameServer本身是没有状态的,并且多个NameServer直接并没有通信,可以横向扩展多台,Broker会和每一台NameServer建立长连接。 BrokerBroker是RocketMQ的核心,提供了消息的接收、存储、拉取等功能,一般都需要保证Broker的高可用,所以会配置Broker Slave,当Master挂掉之后,Consumer然后可以消费Slave。 Broker分为Master和Slave,一个Master可以对应多个Slave,Master与Slave的对应关系通过指定相同的BrokerName,不同的BrokerId来定义,BrokerId为0表示Master,非0表示Slave； Producer消息队列的生产者,需要与NameServer建立连接,从NameServer获取Topic路由信息,并向提供Topic服务的Broker Master建立连接；Producer无状态,看集群部署； Consumer消息队列的消费者,同样与NameServer建立连接,从NameServer获取Topic路由信息,并向提供Topic服务的Broker Master,Slave建立连接；","categories":[{"name":"笔记","slug":"笔记","permalink":"https://lennuo.github.io/PersonalBlog/categories/笔记/"}],"tags":[],"keywords":[{"name":"笔记","slug":"笔记","permalink":"https://lennuo.github.io/PersonalBlog/categories/笔记/"}]},{"title":"【Leetcode】求和路径","slug":"suanfa/求和路径","date":"2021-02-22T06:11:22.000Z","updated":"2021-02-22T07:43:45.351Z","comments":false,"path":"2021/02/22/suanfa/求和路径/","link":"","permalink":"https://lennuo.github.io/PersonalBlog/2021/02/22/suanfa/求和路径/","excerpt":"","text":"题目给定一棵二叉树，其中每个节点都含有一个整数数值(该值或正或负)。设计一个算法，打印节点数值总和等于某个给定值的所有路径的数量。注意，路径不一定非得从二叉树的根节点或叶节点开始或结束，但是其方向必须向下(只能从父节点指向子节点方向)。 链接 思路一开始从上往下找,但出现了多次重复的情况,改了很多次也就过了百分85的案例,看了下一个人解答 通过 层次存每一个值 从下往上倒推,这样子就避免了重复的问题,速度还特别快。 代码/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { static int ans = 0; public static int pathSum(TreeNode root, int sum) { ans = 0; int depth = depth(0, root); int []path = new int[depth+2]; dfs(root, path, 1, sum); return ans; } static void dfs(TreeNode node,int []path,int level,int target) { if(node==null) { return ; } path[level] = node.val; int sum = 0; for(int i = level;i&gt;0;i--) { sum = sum + path[i]; if(sum==target) { ans++; } } dfs(node.left, path, level+1, target); dfs(node.right, path, level+1, target); } static int depth(int level,TreeNode node) { if(node == null) return 0; return Math.max(depth(level+1, node.left), depth(level+1, node.right)) + 1; } }","categories":[{"name":"算法","slug":"算法","permalink":"https://lennuo.github.io/PersonalBlog/categories/算法/"}],"tags":[],"keywords":[{"name":"算法","slug":"算法","permalink":"https://lennuo.github.io/PersonalBlog/categories/算法/"}]},{"title":"【Leetcode】236 二叉树的最近公共祖先","slug":"suanfa/236二叉树的最近公共祖先","date":"2021-02-21T07:11:22.000Z","updated":"2021-02-21T07:50:36.589Z","comments":false,"path":"2021/02/21/suanfa/236二叉树的最近公共祖先/","link":"","permalink":"https://lennuo.github.io/PersonalBlog/2021/02/21/suanfa/236二叉树的最近公共祖先/","excerpt":"","text":"题目给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 链接 示例1输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出：3 解释：节点 5 和节点 1 的最近公共祖先是节点 3 。 2输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出：5 解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。 3输入：root = [1,0,2] 输出：[3,3,2] 4输入：root = [3,2,4,1] 输出：[7,9,4,10] 提示： 树中节点数目在范围 [2, 10^5] 内。 -10^9 &lt;= Node.val &lt;= 10^9 所有 Node.val 互不相同 。 p != q p 和 q 均存在于给定的二叉树中。 思路有三种情况： 左右边都有一个 全部在左边 全部在右边那么递归就好了去做三个判断两边都有他就是根了,直接返回他就好了 代码/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public static TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { return find(root, p, q); } static TreeNode find(TreeNode node,TreeNode p,TreeNode q) { if(node==null) { return null; } if(node.val==p.val || node.val==q.val) { return node; } else { TreeNode left = find(node.left, p, q); TreeNode right = find(node.right, p, q); if(left!=null &amp;&amp; right!=null) { return node; } else if(left==null) { return right; } else { return left; } } } }","categories":[{"name":"算法","slug":"算法","permalink":"https://lennuo.github.io/PersonalBlog/categories/算法/"}],"tags":[],"keywords":[{"name":"算法","slug":"算法","permalink":"https://lennuo.github.io/PersonalBlog/categories/算法/"}]},{"title":"【MAVEN】记一次因为Maven没有及时更新产生的问题","slug":"jishu/mavenproblem-2-21","date":"2021-02-21T03:11:22.000Z","updated":"2021-02-21T03:34:23.325Z","comments":false,"path":"2021/02/21/jishu/mavenproblem-2-21/","link":"","permalink":"https://lennuo.github.io/PersonalBlog/2021/02/21/jishu/mavenproblem-2-21/","excerpt":"","text":"2021-02-21 02:25:00今天把模块全部打包部署，一开始顺顺利利，测了一遍都没有问题，然后因为有一些显示的原因给路径多加了一个前缀，惨案来了，再次请求找不到了，feign请求404了，跑了下本地发现成功的，试了几次更换前缀都是成功的，打包去跑就是404，这个时候就感觉是打包时候缓存的问题，但不知道是哪块出了问题。第一反应是调用方，之前也出现过这个模块缓存不更新，尝试直接请求接口发现可以用的。然后去服务器上检查注册中心，发现也没有问题，那就肯定是打包出问题了。做了对照实验，一次用了第一次打包的路径，请求成功了。第二次随便输入，请求失败了。第三次修改了服务名称，feign用了修改后随便输入，发现他还是报的最早的路径。好了又被缓存坑了，接下来不管是clean也好，直接编译器清缓存都清空不掉，最气的是本地就是好好的，就给你打包后报。最后直接换了2019.3的编译器，以前一直用这个版本，新装了系统才装了2020.3的。不知道是重新加载的原因还是编译器的原因，反正修改了几个小问题就好了，然后发现公共包里面有一个引用问题，讲道理会报错的，之前居然平安无事地运行了半个月都没有提示。现在是2.25了，睡觉睡觉，本来今天还想早睡。 2021-02-21 11:28:00现在仔细想想也有可能是的那个没有修改的小bug的原因,因为报错可能导致依赖他生产者模块没有成功的重新加载,以后还是要多注意maven的坑,以前都没有这么在意过,这次写 微服务 项目的时候发生过好几次因为加载时候没有更新依赖出现的问题。","categories":[{"name":"开发","slug":"开发","permalink":"https://lennuo.github.io/PersonalBlog/categories/开发/"}],"tags":[],"keywords":[{"name":"开发","slug":"开发","permalink":"https://lennuo.github.io/PersonalBlog/categories/开发/"}]},{"title":"【MYSQL】索引基础篇","slug":"mianshi/mysql/suoying","date":"2021-02-19T11:04:22.000Z","updated":"2021-02-19T12:43:28.938Z","comments":false,"path":"2021/02/19/mianshi/mysql/suoying/","link":"","permalink":"https://lennuo.github.io/PersonalBlog/2021/02/19/mianshi/mysql/suoying/","excerpt":"","text":"张三接收了一个老项目,查数据的时候经常会被吐槽查询速度慢,数据出不来。终于它炸了,出不来数据了(又该祭天程序员了),经过检查发现数据多的已经查询数据库要几分钟了,这个时候 索引 站了出来 概念[1]我们知道数据库的数据最终它都会存储在文件中。那么我们查找id为1的数据时，我们会这么写：SELECT FROM person WHERE ID = 1.如果没有索引，我们怎么查询呢，我想我们只能读取文件，逐行扫描，找到符合的结果。如果 我们再来查询：SELECT FROM person WHERE ID = 3,那么有需要读取文件，逐行扫描，这样子效率会特别差。这时候就需要有一种东西可以帮助我们实现高效的获取数据。索引就这么出现了。在讨论索引之前，还要讨论一下底层文件系统是怎么样进行读取，写入数据的。 如图一，在文件系统中，table表是这么存储的，有一个文件名，文件名对应着一个三元组（柱面，磁道，扇区），当我们要去读机械硬盘时，我们需要通过我们的柱面，磁道定位到扇区，然后找到table.idb存储在图右磁盘的红色区域内，读取数据时（假设顺时钟），将会从A依次读到B,这就是原始存储和读取方式。所以当我们每次查找的时候都是需要如图2 中从A到B的扫描读取，效率很低。 索引数据结构索引默认用的数据结构是B+树,作为对比先聊聊Hash和B树。 Hash Hash我们知道是可以算出来Hash算法算出一个特定的下标,来存储数据。但是他适用于特定的查找,比如查找条件 age = 15,但如果查找条件 age &gt;= 14,那么他只能通过全表扫描,筛选出符合条件的数据。 数据量大的时候Hash的碰撞会比较严重。 无法进行索引排序 不支持多列联合索引的最左匹配规则 B树[1]首先先简单介绍下什么叫做B树(多路搜索树),一听名字为了搜索数据而生的,它不一定是二叉的哦。 定义非叶子节点的个数最多为M,且M&gt;2 根节点的儿子数为[2,M] 除根节点以外的非叶子节点的儿子数量[M/2,M] 每一个结点至少存放 M/2-1(向上取整)和最多M-1个关键字 非叶子节点的关键字个数 = 儿子个数 - 1 非叶子节点关键字:K[1],K[2]….K[M-1],且K[n] &lt; K[n+1] 非叶子节点的指针:P[1],P[2]….P[M],且P[1]指向的关键字小于K[1] 所有叶子节点位于同一层 B+树B+树是B树的一个扩展,提高IO性能,解决元素遍历效率低下 与B树的不同 有M棵子树的非叶子结点中含有M个关键字（b树是M-1个），这些关键字不保存数据，只用来索引，所有数据都保存在叶子节点（B树是每个关键字都保存数据）。 所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。 所有的非叶子结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。 优势 B+树的中间节点不保存数据，所以磁盘页能容纳更多节点元素，更“矮胖”； B+树查询必须查找到叶子节点，B树只要匹配到即可不用管元素位置，因此B+树查找更稳定（并不慢）； 对于范围查找来说，B+树只需遍历叶子节点链表即可，b树却需要重复地中序遍历 索引面试题[2]索引概念、索引模型我们是怎么聊到索引的呢，是因为我提到我们的业务量比较大，每天大概有几百万的新数据生成，于是有了以下对话：Q：你们每天这么大的数据量，都是保存在关系型数据库中吗？A：是的，我们线上使用的是MySQL数据库Q：每天几百万数据，一个月就是几千万了，那你们有没有对于查询做一些优化呢？A：我们在数据库中创建了一些索引（我现在非常后悔我当时说了这句话） 这里可以看到，阿里的面试官并不会像有一些公司一样拿着题库一道一道的问，而是会根据面试者做过的事情以及面试过程中的一些内容进行展开。 Q：那你能说说什么是索引吗？A：（这道题肯定难不住我啊）索引其实是一种数据结构，能够帮助我们快速的检索数据库中的数据Q：那么索引具体采用的哪种数据结构呢？A：（这道题我也背过）常见的MySQL主要有两种结构：Hash索引和B+ Tree索引，我们使用的是InnoDB引擎，默认的是B+树 这里我耍了一个小心机，特意说了一下索引和存储引擎有关。希望面试官可以问我一些关于存储引擎的问题。然而面试官并没有被我带跑… Q：既然你提到InnoDB使用的B+ 树的索引模型，那么你知道为什么采用B+ 树吗？这和Hash索引比较起来有什么优缺点吗？A：（突然觉得这道题有点难，但是我还是凭借着自己的知识储备简单的回答上一些）因为Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。而B+ 树是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描Q：除了上面这个范围查询的，你还能说出其他的一些区别吗？A：（这个题我回答的不好，事后百度了一下）B+ Tree索引和Hash索引区别？ 哈希索引适合等值查询，但是无法进行范围查询 哈希索引没办法利用索引完成排序 哈希索引不支持多列联合索引的最左匹配规则 如果有大量重复键值的情况下，哈希索引的效率会很低，因为存在哈希碰撞问题 聚簇索引、覆盖索引Q：刚刚我们聊到B+ Tree ，那你知道B+ Tree的叶子节点都可以存哪些东西吗？A：InnoDB的B+ Tree可能存储的是整行数据，也有可能是主键的值Q：那这两者有什么区别吗？A：（当他问我叶子节点的时候，其实我就猜到他可能要问我聚簇索引和非聚簇索引了）在 InnoDB 里，索引B+ Tree的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引。而索引B+ Tree的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引Q：那么，聚簇索引和非聚簇索引，在查询数据的时候有区别吗？A：聚簇索引查询会更快？Q：为什么呢？A：因为主键索引树的叶子节点直接就是我们要查询的整行数据了。而非主键索引的叶子节点是主键的值，查到主键的值以后，还需要再通过主键的值再进行一次查询Q：刚刚你提到主键索引查询只会查一次，而非主键索引需要回表查询多次。（后来我才知道，原来这个过程叫做回表）是所有情况都是这样的吗？非主键索引一定会查询多次吗？A：（额、这个问题我回答的不好，后来我自己查资料才知道，通过覆盖索引也可以只查询 覆盖索引？覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。当一条查询语句符合覆盖索引条件时，MySQL只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I/O提高效率。如，表covering_index_sample中有一个普通索引 idx_key1_key2(key1,key2)。当我们通过SQL语句：select key2 from covering_index_sample where key1 = ‘keytest’;的时候，就可以通过覆盖索引查询，无需回表。 联合索引、最左前缀匹配Q：不知道的话没关系，想问一下，你们在创建索引的时候都会考虑哪些因素呢？A：我们一般对于查询概率比较高，经常作为where条件的字段设置索引Q： 那你们有用过联合索引吗？A：用过呀，我们有对一些表中创建过联合索引Q：那你们在创建联合索引的时候，需要做联合索引多个字段之间顺序你们是如何选择的呢？A：我们把识别度最高的字段放到最前面Q：为什么这么做呢？A：（这个问题有点把我问蒙了，稍微有些慌乱）这样的话可能命中率会高一点吧。。。Q： 那你知道最左前缀匹配吗？A：（我突然想起来原来面试官是想问这个，怪自己刚刚为什么就没想到这个呢。）哦哦哦。您刚刚问的是这个意思啊，在创建多列索引时，我们根据业务需求，where子句中使用最频繁的一列放在最左边，因为MySQL索引查询会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。所以当我们创建一个联合索引的时候，如(key1,key2,key3)，相当于创建了（key1）、(key1,key2)和(key1,key2,key3)三个索引，这就是最左匹配原则 索引下推、查询优化Q：你们线上用的MySQL是哪个版本啊呢？A：我们MySQL是5.7Q：那你知道在MySQL 5.6中，对索引做了哪些优化吗？A：不好意思，这个我没有去了解过。（事后我查了一下，有一个比较重要的 ：Index Condition Pushdown Optimization） 查询优化器？一条SQL语句的查询，可以有不同的执行方案，至于最终选择哪种方案，需要通过优化器进行选择，选择执行成本最低的方案。在一条单表查询语句真正执行之前，MySQL的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案。这个成本最低的方案就是所谓的执行计划。优化过程大致如下：1、根据搜索条件，找出所有可能使用的索引2、计算全表扫描的代价3、计算使用不同索引执行查询的代价4、对比各种执行方案的代价，找出成本最低的那一个 感觉是因为我回答的不够好，如果这几个索引问题我都会的话，他还会追问更多，恐怕会被虐的更惨 总结&amp;感悟以上，就是一次面试中关于索引部分知识的问题以及我整理的答案。感觉这次面试过程中关于索引的知识，自己大概能够回答的内容占70%左右，但是自信完全答对的内容只占50%左右，看来自己索引有关的知识了解的还是不够多。 通过这次面试，发现像阿里这种大厂对于底层知识还是比较看重的，我以前以为关于索引最多也就问一下Hash和B+有什么区别，没想到最后都能问到查询优化器上面。 最后，不管本次面试能不能通过，都非常感谢有这样一次机会，可以让自己看到自己的不足。通过这次面试，我也收获了很多东西。加油！ 引用资料[1] Object_PigMan https://blog.csdn.net/javawcj123/article/details/79824020[2] Hollis https://mp.weixin.qq.com/s/_bk2JVOm2SkXfdcvki6-0w","categories":[{"name":"面试","slug":"面试","permalink":"https://lennuo.github.io/PersonalBlog/categories/面试/"}],"tags":[],"keywords":[{"name":"面试","slug":"面试","permalink":"https://lennuo.github.io/PersonalBlog/categories/面试/"}]},{"title":"【MYSQL】事务篇","slug":"mianshi/mysql/shiwu","date":"2021-02-19T00:11:22.000Z","updated":"2021-02-19T13:22:27.533Z","comments":false,"path":"2021/02/19/mianshi/mysql/shiwu/","link":"","permalink":"https://lennuo.github.io/PersonalBlog/2021/02/19/mianshi/mysql/shiwu/","excerpt":"","text":"事务四大特性(ACID)首先先来了解下什么叫作事务,一般来说一个事务对应着一个完整的业务,举个最常见的栗子(想念下沙举个栗子的第N天)一个银行转账就是能代表着一个事务：张三 转给李四1000 块钱,首先从张三的账户扣 1000 块钱,再加给李四的账户加 1000 块钱。 原子性一番操作后显示“转账成功”并扣了钱,打给李四询问情况,李四还没有收到张三的钱，而张三多扣了 1000 块钱,张三这少钱了不得来银行门口闹嘛! 这就说到了事务的第一个特性：原子性,保证共同成功或共同失败,不会出现一个成功,一个失败的情况。 一致性张三 来到了银行门口刚准备闹,经理把他拦了下来说：“这次我们已经把写这个BUG程序员祭天了,钱给您退回来了。”张三又开始了转账操作,给李四又转账了 1000 块钱,这次成功转过去了,张三打电话告知李四没想到被李四一顿臭骂:“你小子**是不是玩我,给我转个 250 是在骂我！！”。 这就是事务的第二个特性：一致性,确保状态一致的。转账服务中转出账户的扣除金额与转入账户的转入金额必须保持一致。 隔离性张三 又找到了银行经理, 气急败坏地刚准备开始讲优美的中国话, 只见天气突变, 一个没有什么头发的男子朝天飞去,经理说：“写出这个BUG的程序员也被祭天了,这次肯定也没有问题”。张三在操作的同时王五给他转了500块钱,读到的是扣了1000块钱的账户余额,但是转给李四的时候账号写错了,导致没有转过去,把账户余额原样,但王五转账操作还是从扣1000块钱的基础上加了500,张三发现自己转账钱没有收到,还平白无故少了500块钱,,经理急忙过来说:“啊啊啊,不好意思,我们又出问题了,这就拿程序员祭天。” 这就是事务的第三个特性：隔离性,针对并发事务而言，事务必须在不干扰其他进程或事务的前提下独立执行，这个例子中出现了脏读王五转进来成功了,但是 持久性又又又一次操作后,张三终于把钱正常的转给了李四,查询了记录这次肯定没有错。 这就是事务的第四个特性：持久性,对数据所作的所有改动都必须在事务成功结束前保存至某种物理存储设备。这样可以保证，所作的修改在任何系统瘫痪时不至于丢失。 锁共享锁(S)读锁：事务A对数据对象加S锁的时候，A和其他的事务能加S锁，但都只能读，也不能加X锁 排他锁(X)读写锁：事务A加了对象X锁后，其他事务不能加任何锁，直到A释放 事务错误情况 脏读：事务A读到了事务B未提交的数据。例如：事务B执行过程中修改了数据X，在未提交前，事务A读取了X，而事务B却回滚了，这样事务A就形成了脏读。 不可重复读：事务A第一次查询得到一行记录row1，事务B提交修改后，事务A第二次查询得到row1，但列内容发生了变化(数据修改)。 幻读：事务A首先根据条件索引得到N条数据，然后事务B改变了这N条数据之外的M条或者增添了M条符合事务A搜索条件的数据，导致事务A再次搜索发现有N+M条数据了，就产生了幻读(数据增加)。 隔离级别 结语愿世界和平、永无bug","categories":[{"name":"面试","slug":"面试","permalink":"https://lennuo.github.io/PersonalBlog/categories/面试/"}],"tags":[],"keywords":[{"name":"面试","slug":"面试","permalink":"https://lennuo.github.io/PersonalBlog/categories/面试/"}]},{"title":"【派大星的独白】一个关于正常人的故事","slug":"yule/paidaxin","date":"2021-02-17T13:47:59.000Z","updated":"2021-02-19T01:43:57.846Z","comments":false,"path":"2021/02/17/yule/paidaxin/","link":"","permalink":"https://lennuo.github.io/PersonalBlog/2021/02/17/yule/paidaxin/","excerpt":"","text":"来自bilibili视频引用 Up主：洛温阿特金森","categories":[{"name":"娱乐","slug":"娱乐","permalink":"https://lennuo.github.io/PersonalBlog/categories/娱乐/"}],"tags":[],"keywords":[{"name":"娱乐","slug":"娱乐","permalink":"https://lennuo.github.io/PersonalBlog/categories/娱乐/"}]},{"title":"【生僻字】（计算机版）计算机系人骄傲地把头抬起","slug":"yule/jisuanji","date":"2021-02-17T13:47:59.000Z","updated":"2021-02-19T01:43:57.662Z","comments":false,"path":"2021/02/17/yule/jisuanji/","link":"","permalink":"https://lennuo.github.io/PersonalBlog/2021/02/17/yule/jisuanji/","excerpt":"","text":"来自bilibili视频引用 Up主：派三叔iPython3","categories":[{"name":"娱乐","slug":"娱乐","permalink":"https://lennuo.github.io/PersonalBlog/categories/娱乐/"}],"tags":[],"keywords":[{"name":"娱乐","slug":"娱乐","permalink":"https://lennuo.github.io/PersonalBlog/categories/娱乐/"}]},{"title":"【集合】HashMap","slug":"mianshi/collection/hashmap","date":"2021-02-16T12:11:22.000Z","updated":"2021-02-19T11:12:24.514Z","comments":false,"path":"2021/02/16/mianshi/collection/hashmap/","link":"","permalink":"https://lennuo.github.io/PersonalBlog/2021/02/16/mianshi/collection/hashmap/","excerpt":"","text":"HashMap存储结构JDK1.7底层数据结构是数组+链表 JDK.1.8底层数据结构是数组+链表+红黑树 PUT方法[1] 扩容机制默认大小为16,最大的容量是2^30,默认因子0.75 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; static final float DEFAULT_LOAD_FACTOR = 0.75f; 例如：16*0.75=12，默认创建一个map对象数组大小是16，当map添加12个元素到的时候就发生扩容， 创建新的数组的大小2*16=32，然后重新计算每个元素在新数组中的位置 HashMap的容量为什么是2的n次幂，和这个(n - 1) &amp; hash的计算方法有着千丝万缕的关系，符号&amp; 是按位与的计算，这是位运算，计算机能直接运算，特别高效，按位与&amp;的计算方法是，只有当对应位 置的数据都为1时，运算结果也为1，当HashMap的容量是2的n次幂时，(n-1)的2进制也就是1111111***111 这样形式的，这样与添加元素的hash值进行位运算时，能够充分的散列，使得添加的元素均匀分布在HashMap 的每个位置上，减少hash碰撞[2] 从代码可以看到扩容就是transfer()方法中用一个容量更大的数组来代替原有的数组 void resize(int newCapacity) { //传入新的容量 Entry[] oldTable = table; //引用扩容前的Entry数组 int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) { //扩容前的数组大小如果已经达到最大(2^30)了 threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了 return; } Entry[] newTable = new Entry[newCapacity]; //初始化一个新的Entry数组 transfer(newTable); //！！将数据转移到新的Entry数组里 table = newTable; //HashMap的table属性引用新的Entry数组 threshold = (int)(newCapacity * loadFactor);//修改阈值 } void transfer(Entry[] newTable) { Entry[] src = table; //src引用了旧的Entry数组 int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) { //遍历旧的Entry数组 Entry&lt;K,V&gt; e = src[j]; //取得旧Entry数组的每个元素 if (e != null) { src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象） do { Entry&lt;K,V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置 e.next = newTable[i]; //标记[1] newTable[i] = e; //将元素放在数组上 e = next; //访问下一个Entry链上的元素 } while (e != null); } } } JDK1.7使用的头插法(先进后出–栈),作者一开始的时候以为先进来的数据肯定会先用到,但是头插法有一个问题例(A-&gt;B-&gt;C) 那么插入顺序就是C-B-A 当多个线程同时扩容的时候,那么A先弹出去,接着是B,可能会是A同一个位置,因为头插法那么就会导致B-&gt;A,形成了死链 JDK1.8使用了尾插法(先进先出–队列)还是同样的例子(A-&gt;B-&gt;C),默认顺序是(A-B-C),就不会出现死链问题. 当然HashMap本身还是不完全的,他没有锁的保护.线程安全当然还要看HashTable和ConcurrentHashMap 引用资料[1] never疯 https://blog.csdn.net/qq_40574571/article/details/97612100[2] 猿人小郑 https://blog.csdn.net/Apeopl/article/details/88935422","categories":[{"name":"面试","slug":"面试","permalink":"https://lennuo.github.io/PersonalBlog/categories/面试/"}],"tags":[],"keywords":[{"name":"面试","slug":"面试","permalink":"https://lennuo.github.io/PersonalBlog/categories/面试/"}]},{"title":"【集合】HashTable-ConcurrentHashMap","slug":"mianshi/collection/HashTable-concurrentHashMap","date":"2021-02-16T11:02:12.000Z","updated":"2021-02-19T11:05:30.162Z","comments":false,"path":"2021/02/16/mianshi/collection/HashTable-concurrentHashMap/","link":"","permalink":"https://lennuo.github.io/PersonalBlog/2021/02/16/mianshi/collection/HashTable-concurrentHashMap/","excerpt":"","text":"HashTable线程安全性书接上回,说到了HashMap是不安全的,说到了HashTable是安全的,直接放源码 public synchronized V get(Object key) { Entry&lt;?,?&gt; tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) { if ((e.hash == hash) &amp;&amp; e.key.equals(key)) { return (V)e.value; } } return null; } public synchronized boolean containsKey(Object key) { Entry&lt;?,?&gt; tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) { if ((e.hash == hash) &amp;&amp; e.key.equals(key)) { return true; } } return false; } 看全部都是加了锁的,所以就是线程安全的了。 与HashMap的不同 HashMap的key可以为null,HashTable是不允许的因为HashTable有个安全失败机制这种机制会导致你读的数据都不一定是最新的,因此当key为null的时候,不确定他是真的包含还是真的没有 初始容量不同HashTable默认是11,HashMap是16 扩容不同HashMap是2倍,HashTable是2倍+1 迭代器不同HashMap迭代器是fail-fast(快速失败),HashTable不是,所以HashTable在迭代的时候可以修改增删数据 快速失败快速失败是java里面所有的集合都有的一个,当对一个集合进行迭代遍历的时候,如果进行增删改操作就会抛出异常,其中有一个变量modCount用来记录修改次数,还有一个变量expectedModCount则是表示迭代器对集合进行修改的次数。在进行next()/hasNext()的时候会检查两个值是否一样,不一样则会抛出异常。 缺点HashTable的优点是能够保证线程的安全性,同时这也是他的一个缺点,他一锁就会把整个对锁住,导致效率极低,因此出现了concurrentHashMap。 ConcurrentHashMapJDK1.7底层结构Segment+HashEntry(数组+链表) ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock, 所以要锁的时候就只会单独锁一个Segment,不会影响其他的Segment。 PUT首先尝试获得锁,如果失败就是有其他线程,那么就自旋尝试获得锁,到一定次数就改为阻塞锁获取先通过 key 定位到 HashEntry,遍历该 HashEntry, 如果不为空则遍历 key 和当前 key 比较是否相等, 相等就覆盖掉旧的 value为空的话就会新建一个 HashEntry 并加入到 Segment 中,同时判断是否需要扩容 GETget不需要修改数据,所以比较高效,第一次Hash到Segment,第二次Hash到具体的元素上。 缺点查询的时候，还得遍历链表，会导致效率很低，这个跟jdk1.7的HashMap是存在的一样问题，所以他在jdk1.8完全优化了。 JDK1.8底层结构Node+CAS+Synchronized PUT 根据 key 计算出 hashcode。 判断是否需要进行初始化。 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。 如果当前位置的 hashcode == MOVED == -1,则需要进行扩容。 如果都不满足，则利用 synchronized 锁写入数据。 如果数量大于 TREEIFY_THRESHOLD 则要转换为红黑树。 GET 先根据key的hash定位,如果在桶上直接返回 如果是红黑树那就按红黑树遍历 不满足就按链表方式遍历","categories":[{"name":"面试","slug":"面试","permalink":"https://lennuo.github.io/PersonalBlog/categories/面试/"}],"tags":[],"keywords":[{"name":"面试","slug":"面试","permalink":"https://lennuo.github.io/PersonalBlog/categories/面试/"}]},{"title":"【Leetcode】538 把二叉搜索树转换为累加树","slug":"suanfa/538把二叉搜索树转换为累加树","date":"2021-02-10T14:11:22.000Z","updated":"2021-02-21T04:08:29.177Z","comments":false,"path":"2021/02/10/suanfa/538把二叉搜索树转换为累加树/","link":"","permalink":"https://lennuo.github.io/PersonalBlog/2021/02/10/suanfa/538把二叉搜索树转换为累加树/","excerpt":"","text":"题目给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。 提醒一下，二叉搜索树满足下列约束条件： 节点的左子树仅包含键 小于 节点键的节点。节点的右子树仅包含键 大于 节点键的节点。左右子树也必须是二叉搜索树。 示例1 输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8] 输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8] 2输入：root = [0,null,1] 输出：[1,null,1] 3输入：root = [1,0,2] 输出：[3,3,2] 4输入：root = [3,2,4,1] 输出：[7,9,4,10] 提示： 树中的节点数介于 0 和 104 之间。 每个节点的值介于 -104 和 104 之间。 树中的所有值 互不相同 。 给定的树为二叉搜索树。 思路由题的图可以看出,是反向的中序遍历,先访问右子树,然后更新根节点的值,把根节点的值存下来累加到左子树全部累加根节点的值。 代码/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { static int num = 0; public static TreeNode convertBST(TreeNode root) { dfs(root); num = 0; return root; } static void dfs(TreeNode root) { if(root==null) { return ; } dfs(root.right); root.val = root.val + num; num = root.val; dfs(root.left); return ; } }","categories":[{"name":"算法","slug":"算法","permalink":"https://lennuo.github.io/PersonalBlog/categories/算法/"}],"tags":[],"keywords":[{"name":"算法","slug":"算法","permalink":"https://lennuo.github.io/PersonalBlog/categories/算法/"}]},{"title":"【16th浙江省ACM比赛】Welcome Party","slug":"suanfa/zoj-Welcome Party","date":"2021-02-01T02:10:22.000Z","updated":"2021-02-21T05:10:08.687Z","comments":false,"path":"2021/02/01/suanfa/zoj-Welcome Party/","link":"","permalink":"https://lennuo.github.io/PersonalBlog/2021/02/01/suanfa/zoj-Welcome Party/","excerpt":"","text":"题目题目太长了直接放链接 大概题意a-b是朋友，b-c是朋友,但a-c不一定是朋友,现在有一个房间让全部的人进入房间,如果房间没有朋友那就不开心,现在让你求出最小的不开心数量以及输出出来进房间的序列 看到这题第一反应就是并查集了,把所有的点全部连起来,然后再找到对应的根,这样子是能够确定最小不开心,但是输出还是一个问题,这个时候就用拓扑排序的方法去跑,把所有的根加到优先队列里面,然后输出他的子项,一直去加入到优先队列,这样子就能保证最小顺序。 代码#include&lt;bits/stdc++.h&gt; using namespace std; int root[1000055]; int find(int x){//找根 while(root[x]!=x){ x = root[x]; } return x; } void union1(int x,int y){ int fx = find(x); int fy = find(y); if(fx&lt;fy){ root[fy]=fx; } else{ root[fx]=fy; } } int vis[1000005]; int ansCount = 0; int ans[1000005]; vector&lt;int&gt; vv[1000005]; void bfs(int st){ priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; pq; pq.push(st); while(!pq.empty()){ int cu = pq.top(); pq.pop(); if(vis[cu]==1) continue;//代表已经访问过了 vis[cu]=1; ans[ansCount++] = cu;//添加进去 for(int i=0;i&lt;vv[cu].size();i++){ int v = vv[cu][i]; if(vis[v]!=1){ pq.push(v); } } } } int main(){ int T; scanf(&quot;%d&quot;,&amp;T); while(T--){ ansCount = 0; int n,m; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); for(int i=0;i&lt;=n;i++){ vv[i].clear(); vis[i]=0; root[i]=i; } for(int i=1;i&lt;=m;i++){ int a,b; scanf(&quot;%d %d&quot;,&amp;a,&amp;b); vv[a].push_back(b); vv[b].push_back(a); union1(a,b); } int ans1 = 0; for(int i=1;i&lt;=n;i++){//如果是指向着自己那么就是根 if(root[i]==i){ ans1++; vv[0].push_back(i);//把根全部加入到数组里面 } } bfs(0); cout&lt;&lt;ans1&lt;&lt;endl; for(int i=1;i&lt;ansCount;i++){ printf(&quot;%d&quot;,ans[i]); if(i==ansCount-1){ printf(&quot;\\n&quot;); } else{ printf(&quot; &quot;); } } } return 0; }","categories":[{"name":"算法","slug":"算法","permalink":"https://lennuo.github.io/PersonalBlog/categories/算法/"}],"tags":[],"keywords":[{"name":"算法","slug":"算法","permalink":"https://lennuo.github.io/PersonalBlog/categories/算法/"}]}]}